<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>MIDI Analyzer & Player (Fixed)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
    }

    .container {
        max-width: 900px;
        margin: 0 auto;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 40px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    h1 {
        text-align: center;
        color: #667eea;
        margin-bottom: 30px;
        font-size: 2.5em;
    }

    .upload-area {
        border: 3px dashed #667eea;
        border-radius: 15px;
        padding: 60px 20px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s;
        margin-bottom: 30px;
        background: #f8f9ff;
    }

    .upload-area:hover {
        border-color: #764ba2;
        background: #f0f1ff;
    }

    .upload-area p {
        color: #667eea;
        font-size: 1.2em;
        font-weight: 600;
    }

    #fileInput {
        display: none;
    }

    .controls {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 15px;
        padding: 25px;
        margin-bottom: 30px;
        color: white;
        display: none;
    }

    .controls.show {
        display: block;
    }

    .control-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
    }

    .tempo-info {
        text-align: center;
    }

    .tempo-info p {
        font-size: 0.9em;
        opacity: 0.9;
        margin-bottom: 5px;
    }

    .tempo-value {
        font-size: 2.5em;
        font-weight: bold;
    }

    .play-btn {
        width: 80px;
        height: 80px;
        border-radius: 50%;
        background: white;
        border: none;
        cursor: pointer;
        font-size: 2em;
        color: #667eea;
        transition: all 0.3s;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .play-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    .play-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .duration-info {
        text-align: center;
    }

    .duration-info p {
        font-size: 0.9em;
        opacity: 0.9;
        margin-bottom: 5px;
    }

    .duration-value {
        font-size: 1.5em;
        font-weight: bold;
    }

    .progress-bar {
        width: 100%;
        height: 8px;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 10px;
        overflow: hidden;
        margin-top: 15px;
    }

    .progress-fill {
        height: 100%;
        background: white;
        width: 0%;
        transition: width 0.1s linear;
    }

    .tracks-container {
        display: none;
    }

    .tracks-container.show {
        display: block;
    }

    .tracks-title {
        font-size: 1.8em;
        color: #667eea;
        margin-bottom: 20px;
    }

    .track {
        background: #f8f9ff;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 15px;
        border: 2px solid #e0e5ff;
        transition: all 0.3s;
    }

    .track:hover {
        border-color: #667eea;
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.1);
    }

    .track-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }

    .track-info h3 {
        color: #333;
        font-size: 1.2em;
        margin-bottom: 5px;
    }

    .track-info p {
        color: #666;
        font-size: 0.9em;
    }

    .mute-btn {
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s;
    }

    .mute-btn.active {
        background: #4caf50;
        color: white;
    }

    .mute-btn.muted {
        background: #f44336;
        color: white;
    }

    .volume-control {
        display: flex;
        align-items: center;
        gap: 15px;
    }

    .volume-icon {
        color: #667eea;
        font-size: 1.3em;
    }

    .volume-slider {
        flex: 1;
        height: 8px;
        border-radius: 10px;
        background: #e0e5ff;
        outline: none;
        cursor: pointer;
    }

    .volume-slider::-webkit-slider-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #667eea;
        cursor: pointer;
        -webkit-appearance: none;
    }

    .volume-slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #667eea;
        cursor: pointer;
        border: none;
    }

    .volume-value {
        font-weight: bold;
        color: #667eea;
        min-width: 45px;
        text-align: right;
    }

    .empty-state {
        text-align: center;
        padding: 40px;
        color: #999;
    }

    .empty-state p {
        font-size: 1.1em;
    }

    .status {
        text-align: center;
        margin-top: 10px;
        font-size: 0.9em;
        color: white;
    }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ MIDI Analyzer & Player</h1>

        <div class="upload-area" onclick="document.getElementById('fileInput').click()">
            <p>üìÅ Click ƒë·ªÉ t·∫£i l√™n file MIDI (.mid)</p>
            <input type="file" id="fileInput" accept=".mid,.midi">
        </div>

        <div class="controls" id="controls">
            <div class="control-row">
                <div class="tempo-info">
                    <p>Tempo</p>
                    <div class="tempo-value" id="tempo">120 BPM</div>
                </div>

                <button class="play-btn" id="playBtn">‚ñ∂Ô∏è</button>

                <div class="duration-info">
                    <p>Th·ªùi l∆∞·ª£ng</p>
                    <div class="duration-value" id="duration">0:00</div>
                </div>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="status" id="status"></div>
        </div>

        <div class="tracks-container" id="tracksContainer">
            <h2 class="tracks-title">Tracks (<span id="trackCount">0</span>)</h2>
            <div id="tracksList"></div>
        </div>

        <div class="empty-state" id="emptyState">
            <p>T·∫£i l√™n file MIDI ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
        </div>
    </div>

<script>
    let midiData = null;
    let tracks = [];
    let synths = [];
    let parts = [];
    let isPlaying = false;
    let timeInterval = null;
    // durationSeconds: total duration in seconds
    let durationSeconds = 0;

    document.getElementById('fileInput').addEventListener('change', handleFileUpload);
    document.getElementById('playBtn').addEventListener('click', togglePlay);

    // Safe gain -> dB helper (avoid depending on library)
    const gainToDb = (g) => {
        if (g <= 0) return -Infinity;
        return 20 * Math.log10(g);
    };

    async function handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        try {
            const arrayBuffer = await file.arrayBuffer();
            const data = new Uint8Array(arrayBuffer);
            midiData = parseMidi(data);
            tracks = midiData.tracks;

            displayMidiInfo();
            renderTracks();

            document.getElementById('controls').classList.add('show');
            document.getElementById('tracksContainer').classList.add('show');
            document.getElementById('emptyState').style.display = 'none';
        } catch (error) {
            alert('L·ªói khi ƒë·ªçc file MIDI: ' + (error.message || error));
            console.error(error);
        }
    }

    function parseMidi(data) {
        let pos = 0;

        const readBytes = (n) => {
            const bytes = data.slice(pos, pos + n);
            pos += n;
            return bytes;
        };

        const readVarLen = () => {
            let value = 0;
            let byte;
            do {
                byte = data[pos++];
                value = (value << 7) | (byte & 0x7f);
            } while (byte & 0x80);
            return value;
        };

        const header = String.fromCharCode(...readBytes(4));
        if (header !== 'MThd') throw new Error('File MIDI kh√¥ng h·ª£p l·ªá');

        // header length (usually 6)
        readBytes(4);

        const dv = new DataView(data.buffer);
        const format = dv.getUint16(pos); pos += 2;
        const trackCount = dv.getUint16(pos); pos += 2;
        const timeDivision = dv.getUint16(pos); pos += 2;

        const tracks = [];
        let globalTempo = 120; // bpm

        for (let i = 0; i < trackCount; i++) {
            const trackHeader = String.fromCharCode(...readBytes(4));
            if (trackHeader !== 'MTrk') {
                // skip if not a track chunk
                continue;
            }

            const trackLength = dv.getUint32(pos); pos += 4;
            const trackEnd = pos + trackLength;

            const events = [];
            let time = 0;
            let lastStatus = 0;
            let trackName = `Track ${i + 1}`;
            let instrumentName = 'Piano';

            while (pos < trackEnd) {
                const delta = readVarLen();
                time += delta;

                let status = data[pos];
                if (status < 0x80) {
                    // running status: reuse lastStatus, don't advance pos
                    status = lastStatus;
                } else {
                    pos++;
                    lastStatus = status;
                }

                // channel message?
                if (status === 0xff) {
                    // meta event
                    const metaType = data[pos++];
                    const length = readVarLen();
                    const metaData = readBytes(length);
                    if (metaType === 0x03) {
                        trackName = String.fromCharCode(...metaData);
                    } else if (metaType === 0x51 && length === 3) {
                        const microsecondsPerBeat = (metaData[0] << 16) | (metaData[1] << 8) | metaData[2];
                        globalTempo = Math.round(60000000 / microsecondsPerBeat);
                    }
                    continue;
                } else if (status === 0xf0 || status === 0xf7) {
                    // sysex
                    const length = readVarLen();
                    pos += length;
                    continue;
                }

                const type = status >> 4;
                const channel = status & 0x0f;

                if (type === 0x9) {
                    const note = data[pos++];
                    const velocity = data[pos++];
                    if (velocity > 0) {
                        events.push({ type: 'noteOn', time, note, velocity, channel });
                    } else {
                        events.push({ type: 'noteOff', time, note, channel });
                    }
                } else if (type === 0x8) {
                    const note = data[pos++];
                    pos++; // velocity
                    events.push({ type: 'noteOff', time, note, channel });
                } else if (type === 0xc) {
                    const program = data[pos++];
                    instrumentName = getInstrumentName(program);
                } else if (type === 0xb || type === 0xe) {
                    pos += 2;
                } else if (type === 0xd || type === 0xa) {
                    pos += 1;
                } else {
                    // unknown - try to avoid infinite loop
                    break;
                }
            }

            if (events.length > 0) {
                tracks.push({
                    name: trackName,
                    instrument: instrumentName,
                    events,
                    volume: 0.7,
                    muted: false
                });
            }
        }

        return { tracks, tempo: globalTempo, timeDivision };
    }

    function getInstrumentName(program) {
        const instruments = [
            'Piano', 'Piano', 'Piano', 'Piano', 'E.Piano', 'E.Piano', 'Harpsichord', 'Clavinet',
            'Celesta', 'Glockenspiel', 'Music Box', 'Vibraphone', 'Marimba', 'Xylophone', 'Tubular Bells', 'Dulcimer',
            'Organ', 'Organ', 'Organ', 'Church Organ', 'Reed Organ', 'Accordion', 'Harmonica', 'Bandoneon',
            'Nylon Guitar', 'Steel Guitar', 'Jazz Guitar', 'Clean Guitar', 'Muted Guitar', 'Overdrive Guitar', 'Distortion Guitar', 'Guitar Harmonics',
            'Acoustic Bass', 'Fingered Bass', 'Picked Bass', 'Fretless Bass', 'Slap Bass', 'Slap Bass', 'Synth Bass', 'Synth Bass',
            'Violin', 'Viola', 'Cello', 'Contrabass', 'Tremolo Strings', 'Pizzicato', 'Harp', 'Timpani',
            'Strings', 'Strings', 'Synth Strings', 'Synth Strings', 'Choir', 'Voice Oohs', 'Synth Voice', 'Orchestra Hit',
            'Trumpet', 'Trombone', 'Tuba', 'Muted Trumpet', 'French Horn', 'Brass', 'Synth Brass', 'Synth Brass',
            'Soprano Sax', 'Alto Sax', 'Tenor Sax', 'Baritone Sax', 'Oboe', 'English Horn', 'Bassoon', 'Clarinet',
            'Piccolo', 'Flute', 'Recorder', 'Pan Flute', 'Bottle', 'Shakuhachi', 'Whistle', 'Ocarina',
            'Square Wave', 'Saw Wave', 'Synth Calliope', 'Chiffer Lead', 'Charang', 'Solo Vox', 'Fifth Sawtooth', 'Bass & Lead',
            'Fantasia', 'Warm Pad', 'Polysynth', 'Space Voice', 'Bowed Glass', 'Metal Pad', 'Halo Pad', 'Sweep Pad',
            'Ice Rain', 'Soundtrack', 'Crystal', 'Atmosphere', 'Brightness', 'Goblin', 'Echo Drops', 'Star Theme',
            'Sitar', 'Banjo', 'Shamisen', 'Koto', 'Kalimba', 'Bagpipe', 'Fiddle', 'Shanai',
            'Tinkle Bell', 'Agogo', 'Steel Drums', 'Woodblock', 'Taiko', 'Melodic Tom', 'Synth Drum', 'Reverse Cymbal',
            'Guitar Fret', 'Breath', 'Seashore', 'Bird', 'Telephone', 'Helicopter', 'Applause', 'Gunshot'
        ];
        return instruments[program] || 'Unknown';
    }

    function displayMidiInfo() {
        if (!midiData) return;
        document.getElementById('tempo').textContent = midiData.tempo + ' BPM';

        let maxTicks = 0;
        midiData.tracks.forEach(track => {
            track.events.forEach(event => {
                if (event.time > maxTicks) maxTicks = event.time;
            });
        });

        // Convert ticks to seconds: seconds = (ticks / ticksPerBeat) * (60 / bpm)
        durationSeconds = (maxTicks / midiData.timeDivision) * (60 / midiData.tempo);
        document.getElementById('duration').textContent = formatTime(durationSeconds);
    }

    function renderTracks() {
        const tracksList = document.getElementById('tracksList');
        const trackCount = document.getElementById('trackCount');

        trackCount.textContent = tracks.length;
        tracksList.innerHTML = '';

        tracks.forEach((track, index) => {
            const trackDiv = document.createElement('div');
            trackDiv.className = 'track';
            trackDiv.innerHTML = `
                <div class="track-header">
                    <div class="track-info">
                        <h3>${escapeHtml(track.name)}</h3>
                        <p>${escapeHtml(track.instrument)}</p>
                    </div>
                    <button class="mute-btn active" onclick="toggleMute(${index})" id="mute-${index}">
                        Active
                    </button>
                </div>
                <div class="volume-control">
                    <span class="volume-icon">üîä</span>
                    <input type="range" class="volume-slider" min="0" max="100" value="${Math.round(track.volume*100)}" 
                           oninput="changeVolume(${index}, this.value)">
                    <span class="volume-value" id="volume-${index}">${Math.round(track.volume*100)}%</span>
                </div>
            `;
            tracksList.appendChild(trackDiv);
        });
    }

    // basic HTML escape for safety in injected strings
    function escapeHtml(s) {
        return String(s).replace(/[&<>"']/g, (m) => ({
            '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#39;'
        })[m]);
    }

    function toggleMute(index) {
        tracks[index].muted = !tracks[index].muted;
        const btn = document.getElementById(`mute-${index}`);

        if (tracks[index].muted) {
            btn.classList.remove('active');
            btn.classList.add('muted');
            btn.textContent = 'Muted';
            if (synths[index]) {
                synths[index].volume.value = -Infinity;
            }
        } else {
            btn.classList.remove('muted');
            btn.classList.add('active');
            btn.textContent = 'Active';
            if (synths[index]) {
                synths[index].volume.value = gainToDb(tracks[index].volume);
            }
        }
    }

    function changeVolume(index, value) {
        const volume = value / 100;
        tracks[index].volume = volume;
        document.getElementById(`volume-${index}`).textContent = value + '%';

        if (synths[index] && !tracks[index].muted) {
            synths[index].volume.value = gainToDb(volume);
        }
    }

    async function togglePlay() {
        if (isPlaying) {
            stopPlayback();
        } else {
            await startPlayback();
        }
    }

    async function startPlayback() {
        const playBtn = document.getElementById('playBtn');
        const status = document.getElementById('status');

        if (!midiData) {
            alert('Ch∆∞a c√≥ file MIDI ƒë∆∞·ª£c t·∫£i l√™n');
            return;
        }

        try {
            playBtn.disabled = true;
            status.textContent = 'ƒêang kh·ªüi ƒë·ªông √¢m thanh...';

            await Tone.start();
            console.log('Tone.js started');

            status.textContent = 'ƒêang t·∫°o synthesizers...';

            // Create synths (one per track)
            synths = tracks.map((track) => {
                const poly = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: 'sine' },
                    envelope: {
                        attack: 0.005,
                        decay: 0.1,
                        sustain: 0.3,
                        release: 0.8
                    }
                }).toDestination();
                // set initial volume (dB)
                poly.volume.value = track.muted ? -Infinity : gainToDb(track.volume);
                return poly;
            });

            status.textContent = 'ƒêang chu·∫©n b·ªã notes...';
            Tone.Transport.bpm.value = midiData.tempo;
            // reset transport to 0 (seconds)
            Tone.Transport.seconds = 0;

            // Create parts: convert ticks -> seconds for times and durations
            parts = tracks.map((track, trackIndex) => {
                const notes = [];
                const noteOnMap = new Map();

                track.events.forEach(event => {
                    // convert tick time to seconds
                    const timeSec = (event.time / midiData.timeDivision) * (60 / midiData.tempo);

                    if (event.type === 'noteOn') {
                        // we key by note+channel to be more robust
                        const key = `${event.note}:${event.channel}`;
                        noteOnMap.set(key, { time: timeSec, velocity: event.velocity });
                    } else if (event.type === 'noteOff') {
                        const key = `${event.note}:${event.channel}`;
                        if (noteOnMap.has(key)) {
                            const noteOn = noteOnMap.get(key);
                            const dur = Math.max(0.01, timeSec - noteOn.time);
                            notes.push({
                                time: noteOn.time,
                                note: Tone.Frequency(event.note, 'midi').toNote(),
                                duration: dur,
                                velocity: noteOn.velocity / 127
                            });
                            noteOnMap.delete(key);
                        }
                    }
                });

                console.log(`Track ${trackIndex}: ${notes.length} notes`);

                if (notes.length === 0 || track.muted) return null;

                // Part expects times in seconds (numbers) or TransportTime strings.
                const part = new Tone.Part((t, note) => {
                    // note: {time, note, duration, velocity}
                    synths[trackIndex].triggerAttackRelease(
                        note.note,
                        note.duration,
                        t,
                        note.velocity
                    );
                }, notes);

                part.start(0);
                return part;
            });

            status.textContent = 'ƒêang ph√°t...';
            Tone.Transport.start();
            isPlaying = true;
            playBtn.textContent = '‚è∏Ô∏è';
            playBtn.disabled = false;

            // Update progress
            if (timeInterval) clearInterval(timeInterval);
            timeInterval = setInterval(() => {
                const currentTime = Tone.Transport.seconds;
                const progress = durationSeconds > 0 ? (currentTime / durationSeconds) * 100 : 0;
                document.getElementById('progressFill').style.width = Math.min(100, progress) + '%';

                if (currentTime >= durationSeconds) {
                    stopPlayback();
                }
            }, 50);

            console.log('Playback started');

        } catch (error) {
            console.error('Playback error:', error);
            status.textContent = 'L·ªói: ' + (error.message || error);
            playBtn.disabled = false;
            stopPlayback();
        }
    }

    function stopPlayback() {
        try {
            Tone.Transport.stop();
            Tone.Transport.cancel(0);
            Tone.Transport.seconds = 0;
        } catch (e) { /* ignore */ }

        synths.forEach(synth => {
            if (synth) {
                try { synth.releaseAll(); } catch(_) {}
                try { synth.dispose(); } catch(_) {}
            }
        });

        parts.forEach(part => {
            if (part) {
                try { part.dispose(); } catch(_) {}
            }
        });

        synths = [];
        parts = [];

        if (timeInterval) {
            clearInterval(timeInterval);
            timeInterval = null;
        }

        isPlaying = false;
        document.getElementById('playBtn').textContent = '‚ñ∂Ô∏è';
        document.getElementById('playBtn').disabled = false;
        document.getElementById('progressFill').style.width = '0%';
        document.getElementById('status').textContent = '';

        console.log('Playback stopped');
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
</script>
</body>
</html>
