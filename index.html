<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Gửi file P2P bằng WebRTC (blob chunk)</title>
<style>
  :root{font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; font-size:16px}
  body{margin:0;padding:16px;background:#fff;color:#111;line-height:1.4}
  h1{font-size:20px;margin:0 0 12px}
  p{margin:8px 0}
  .box{border:1px solid #ddd;border-radius:10px;padding:12px;margin-bottom:12px;background:#f9f9f9}
  label{display:block;margin:8px 0 4px;font-weight:600}
  input[type=file]{font-size:16px}
  textarea{width:100%;min-height:80px;padding:8px;font-size:14px;font-family:monospace;box-sizing:border-box;border-radius:8px}
  button{display:inline-block;padding:10px 12px;margin:6px 6px 6px 0;font-size:16px;border-radius:10px;border:1px solid #007aff;background:#fff;color:#007aff}
  button.primary{background:#007aff;color:#fff;border-color:#007aff}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .small{font-size:13px;color:#666}
  progress{width:100%;height:18px;border-radius:8px}
  .log{font-size:13px;color:#333;max-height:120px;overflow:auto;background:#fff;padding:6px;border-radius:6px;border:1px dashed #eee}
  .meta{font-size:13px;color:#444;margin-top:6px}
  @media(min-width:700px){
    :root{font-size:18px}
  }
</style>
</head>
<body>

<h1>Gửi file trực tiếp (P2P) bằng WebRTC — Dùng Blob & chunk</h1>

<div class="box">
  <strong>Hướng dẫn nhanh (3 bước):</strong>
  <ol class="small">
    <li>Mở trang này trên <strong>Máy A (Người gửi)</strong> và <strong>Máy B (Người nhận)</strong>.</li>
    <li>Máy A nhấn <em>Tạo Offer</em> → copy nội dung (ô Offer) → dán vào ô Offer trên Máy B → Máy B nhấn <em>Tạo Answer</em> → copy Answer → dán lại vào ô Answer trên Máy A → nhấn <em>Kết nối (Set Remote)</em>.</li>
    <li>Khi kênh dữ liệu mở, Máy A chọn file → nhấn Gửi. Máy B sẽ tự động tải file về.</li>
  </ol>
  <div class="meta">Mẹo: nếu hai máy cùng Wi-Fi, tốc độ rất nhanh. Nếu không kết nối được, thử đổi trình duyệt hoặc dùng mạng khác.</div>
</div>

<div class="box">
  <label>1) Trạng thái</label>
  <div class="row">
    <div id="pcState" class="meta">PeerConnection: ❌ chưa tạo</div>
    <div id="dcState" class="meta">DataChannel: ❌ chưa tạo</div>
  </div>
  <div style="margin-top:8px;">
    <button id="createOffer" class="primary">Tạo Offer (Người gửi)</button>
    <button id="createAnswer">Tạo Answer (Người nhận)</button>
    <button id="setRemote">Kết nối (Set Remote)</button>
    <button id="closeConn">Đóng kết nối</button>
  </div>
</div>

<div class="box">
  <label>2) Signaling (copy–paste giữa 2 máy)</label>
  <div style="margin-bottom:6px"><strong>Offer</strong></div>
  <textarea id="offerText" placeholder="Offer sẽ xuất hiện ở đây (copy từ máy gửi)"></textarea>
  <div style="margin-top:8px"><strong>Answer</strong></div>
  <textarea id="answerText" placeholder="Answer sẽ xuất hiện ở đây (copy từ máy nhận)"></textarea>
</div>

<div class="box">
  <label>3) Chọn file để gửi (Máy gửi)</label>
  <input type="file" id="fileInput" />
  <div class="row" style="margin-top:8px">
    <button id="sendFileBtn" class="primary" disabled>Gửi file</button>
    <button id="cancelSend" disabled>Hủy gửi</button>
  </div>
  <div style="margin-top:8px">
    <progress id="sendProgress" value="0" max="100" hidden></progress>
    <div id="sendInfo" class="small"></div>
  </div>
</div>

<div class="box">
  <label>4) Người nhận (tự động tải về khi nhận xong)</label>
  <progress id="recvProgress" value="0" max="100" hidden></progress>
  <div id="recvInfo" class="small">Chưa nhận file</div>
</div>

<div class="box">
  <label>Log / Thông báo</label>
  <div id="log" class="log"></div>
</div>

<script>
/*
  WebRTC P2P file transfer demo using DataChannel and chunking.
  - Chunks size: 64KB (adjustable)
  - Protocol:
      1) Sender sends JSON metadata: {type:"meta", name, size, mime, chunkSize}
      2) Receiver responds ready.
      3) Sender sends chunks as ArrayBuffer.
      4) Sender sends {type:"done"} to finish.
*/

const CHUNK_SIZE = 64 * 1024; // 64KB per chunk - ổn định cho mobile
const pcConfig = {
  iceServers: [
    { urls: "stun:stun.l.google.com:19302" }
    // Nếu cần TURN, thêm ở đây
  ]
};

let pc = null;
let dataChannel = null;
let isSender = false;
let fileToSend = null;
let fileReader = null;
let sendAbort = false;

const el = id => document.getElementById(id);
const log = msg => {
  const box = el('log');
  const p = document.createElement('div');
  p.textContent = new Date().toLocaleTimeString() + ' — ' + msg;
  box.prepend(p);
};

function updateStatus(){
  el('pcState').textContent = pc ? 'PeerConnection: ✅ tạo' : 'PeerConnection: ❌ chưa tạo';
  el('dcState').textContent = dataChannel ? `DataChannel: ${dataChannel.readyState}` : 'DataChannel: ❌ chưa tạo';
}

function createPeerConnection(){
  if (pc) return pc;
  pc = new RTCPeerConnection(pcConfig);

  pc.onicecandidate = e => {
    if (e.candidate) return;
    // ICE hoàn tất — localDescription có thể chứa ICE candidates (khi không có server)
    log('ICE gathering finished');
  };

  pc.onconnectionstatechange = () => {
    log('Connection state: ' + pc.connectionState);
    updateStatus();
  };

  pc.oniceconnectionstatechange = () => {
    log('ICE connection: ' + pc.iceConnectionState);
    updateStatus();
  };

  pc.ondatachannel = e => {
    dataChannel = e.channel;
    setupDataChannel();
    log('Nhận DataChannel từ remote: ' + dataChannel.label);
    updateStatus();
  };

  updateStatus();
  return pc;
}

function setupDataChannel(){
  if(!dataChannel) return;
  dataChannel.binaryType = 'arraybuffer';
  dataChannel.onopen = () => {
    log('DataChannel mở: ' + dataChannel.readyState);
    updateStatus();
    el('sendFileBtn').disabled = false;
  };
  dataChannel.onclose = () => {
    log('DataChannel đóng');
    updateStatus();
    el('sendFileBtn').disabled = true;
  };
  dataChannel.onerror = err => log('DataChannel error: ' + err);
  dataChannel.onmessage = onMessage;
}

async function onMessage(evt){
  try {
    if (typeof evt.data === 'string') {
      // Có thể nhận thông báo JSON
      const msg = JSON.parse(evt.data);
      if (msg.type === 'meta') {
        // bắt đầu nhận file
        receiveMeta(msg);
      } else if (msg.type === 'done') {
        finishReceive();
      } else if (msg.type === 'ready') {
        // sender: receiver đã sẵn sàng
        log('Receiver đã sẵn sàng nhận file');
        sendChunks(); // bắt đầu gửi
      } else {
        log('Chuỗi JSON nhận được: ' + evt.data);
      }
    } else if (evt.data instanceof ArrayBuffer) {
      // dữ liệu chunk
      handleChunk(evt.data);
    } else {
      log('Nhận dữ liệu khác: ' + typeof evt.data);
    }
  } catch (e) {
    log('Lỗi onMessage: ' + e);
  }
}

/* ======= Receiver side ======= */
let recvBuffer = [];
let recvMeta = null;
let recvReceivedBytes = 0;

function receiveMeta(meta){
  recvMeta = meta;
  recvBuffer = [];
  recvReceivedBytes = 0;
  el('recvInfo').textContent = `Đang chuẩn bị nhận: ${meta.name} (${Math.round(meta.size/1024)} KB)`;
  el('recvProgress').max = meta.size;
  el('recvProgress').value = 0;
  el('recvProgress').hidden = false;
  // gửi trả lời ready
  dataChannel.send(JSON.stringify({type:'ready'}));
  log('Gửi ready để báo nhận file');
}

function handleChunk(arrayBuffer){
  recvBuffer.push(new Uint8Array(arrayBuffer));
  recvReceivedBytes += arrayBuffer.byteLength;
  el('recvProgress').value = recvReceivedBytes;
  el('recvInfo').textContent = `Đang nhận ${recvMeta ? recvMeta.name : ''} — ${Math.round(recvReceivedBytes/1024)}/${Math.round(recvMeta.size/1024)} KB`;
}

function finishReceive(){
  const received = new Blob(recvBuffer, { type: recvMeta.mime });
  const url = URL.createObjectURL(received);
  const a = document.createElement('a');
  a.href = url;
  a.download = recvMeta.name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  el('recvInfo').textContent = `Hoàn tất: ${recvMeta.name} (${Math.round(recvMeta.size/1024)} KB)`;
  el('recvProgress').hidden = true;
  log('Nhận file xong: ' + recvMeta.name);
  recvMeta = null;
  recvBuffer = [];
  recvReceivedBytes = 0;
}

/* ======= Sender side ======= */
let filePos = 0;
let totalChunks = 0;
let lastChunkSize = 0;

function prepareSend(file){
  fileToSend = file;
  filePos = 0;
  totalChunks = Math.ceil(file.size / CHUNK_SIZE);
  lastChunkSize = file.size - (totalChunks-1)*CHUNK_SIZE;
  el('sendInfo').textContent = `Chuẩn bị gửi: ${file.name} — ${Math.round(file.size/1024)} KB (${totalChunks} phần)`;
  el('sendProgress').max = file.size;
  el('sendProgress').value = 0;
  el('sendProgress').hidden = false;
  el('sendFileBtn').disabled = false;
}

function abortSend(){
  sendAbort = true;
  if (fileReader) fileReader.abort();
  el('sendInfo').textContent = 'Đã hủy gửi';
  el('sendProgress').hidden = true;
  log('Sender: gửi bị hủy');
}

function sendMeta(){
  if (!dataChannel || dataChannel.readyState !== 'open') return log('Kênh dữ liệu chưa mở');
  const meta = {
    type: 'meta',
    name: fileToSend.name,
    size: fileToSend.size,
    mime: fileToSend.type || 'application/octet-stream',
    chunkSize: CHUNK_SIZE
  };
  dataChannel.send(JSON.stringify(meta));
  log('Gửi meta: ' + meta.name + ' — ' + meta.size + ' bytes');
  // actual send starts when receiver responds 'ready'
}

function sendChunks(){
  if (!fileToSend) return;
  sendAbort = false;
  filePos = 0;
  fileReader = new FileReader();
  fileReader.onerror = e => { log('FileReader error: ' + e); };
  fileReader.onabort = () => log('FileReader aborted');
  fileReader.onload = e => {
    if (sendAbort) return;
    const buffer = e.target.result;
    // nếu dataChannel buffer đầy, chờ
    try {
      dataChannel.send(buffer);
    } catch (err) {
      log('Lỗi gửi chunk: ' + err);
      return;
    }
    filePos += buffer.byteLength;
    el('sendProgress').value = filePos;
    el('sendInfo').textContent = `Đã gửi ${Math.round(filePos/1024)}/${Math.round(fileToSend.size/1024)} KB`;
    if (filePos < fileToSend.size) {
      sendSlice();
    } else {
      // xong
      dataChannel.send(JSON.stringify({type:'done'}));
      el('sendInfo').textContent = `Hoàn tất gửi: ${fileToSend.name}`;
      el('sendProgress').hidden = true;
      log('Sender: gửi hoàn thành');
    }
  };

  function sendSlice(){
    const end = Math.min(filePos + CHUNK_SIZE, fileToSend.size);
    const slice = fileToSend.slice(filePos, end);
    fileReader.readAsArrayBuffer(slice);
  }

  // bắt đầu gửi
  sendSlice();
}

/* ======= Buttons & UI handlers ======= */

el('createOffer').addEventListener('click', async () => {
  isSender = true;
  createPeerConnection();
  dataChannel = pc.createDataChannel('file-transfer');
  setupDataChannel();

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  // chờ ICE gather complete (simple approach: wait a bit) then output localDescription
  await waitForIceGatheringComplete(pc);
  el('offerText').value = JSON.stringify(pc.localDescription);
  log('Offer đã tạo — copy ô Offer và gửi cho bên nhận');
  updateStatus();
});

el('createAnswer').addEventListener('click', async () => {
  isSender = false;
  createPeerConnection();

  const offerText = el('offerText').value.trim();
  if (!offerText) { log('Không có Offer để xử lý'); return; }

  try {
    const offer = JSON.parse(offerText);
    await pc.setRemoteDescription(offer);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    await waitForIceGatheringComplete(pc);
    el('answerText').value = JSON.stringify(pc.localDescription);
    log('Answer đã tạo — copy ô Answer trả về cho người gửi');
  } catch (e) {
    log('Lỗi tạo Answer: ' + e);
  }
  updateStatus();
});

el('setRemote').addEventListener('click', async () => {
  const txt = el('answerText').value.trim();
  if (!txt) { log('Không có Answer để set remote'); return; }
  try {
    const answer = JSON.parse(txt);
    await pc.setRemoteDescription(answer);
    log('Đã set remote description (answer) — chờ kết nối');
  } catch (e) {
    log('Lỗi setRemote: ' + e);
  }
  updateStatus();
});

el('closeConn').addEventListener('click', () => {
  if (dataChannel) {
    try { dataChannel.close(); } catch(e){}
    dataChannel = null;
  }
  if (pc) {
    try { pc.close(); } catch(e){}
    pc = null;
  }
  updateStatus();
  log('Kết nối đã đóng bởi người dùng');
});

el('fileInput').addEventListener('change', (ev) => {
  const f = ev.target.files[0];
  if (!f) return;
  prepareSend(f);
});

el('sendFileBtn').addEventListener('click', () => {
  if (!dataChannel || dataChannel.readyState !== 'open') {
    log('Kênh dữ liệu chưa mở, không thể gửi');
    return;
  }
  if (!fileToSend) { log('Chưa chọn file để gửi'); return; }
  // bắt đầu quá trình: gửi meta -> receiver trả ready -> sender gửi chunks
  sendMeta();
  el('sendFileBtn').disabled = true;
  el('cancelSend').disabled = false;
});

el('cancelSend').addEventListener('click', () => {
  abortSend();
  el('cancelSend').disabled = true;
  el('sendFileBtn').disabled = false;
});

/* ======= Utils ======= */

function waitForIceGatheringComplete(pcInstance, timeoutMs = 3000){
  return new Promise((resolve) => {
    if (!pcInstance) return resolve();
    if (pcInstance.iceGatheringState === 'complete') return resolve();
    const check = () => {
      if (pcInstance.iceGatheringState === 'complete') {
        pcInstance.removeEventListener('icegatheringstatechange', check);
        resolve();
      }
    };
    pcInstance.addEventListener('icegatheringstatechange', check);
    // fallback timeout
    setTimeout(() => {
      try { pcInstance.removeEventListener('icegatheringstatechange', check); } catch(e){}
      resolve();
    }, timeoutMs);
  });
}

updateStatus();
log('Trang sẵn sàng. Thực hiện theo hướng dẫn phía trên để kết nối 2 máy.');

</script>
</body>
</html>